import copy
import warnings
import pandas as pd
from typing import Union

from ...utils import init_instance_by_config
from ...utils.resam import parse_freq


from .order import Order
from .account import Account
from .exchange import Exchange
from .utils import TradeCalendarManager


class BaseExecutor:
    """Base executor for trading"""

    def __init__(
        self,
        step_bar: str,
        start_time: Union[str, pd.Timestamp] = None,
        end_time: Union[str, pd.Timestamp] = None,
        generate_report: bool = False,
        verbose: bool = False,
        track_data: bool = False,
        common_infra: dict = {},
        **kwargs,
    ):
        """
        Parameters
        ----------
        generate_report : bool, optional
            whether to generate report, by default False
        verbose : bool, optional
            whether to print trading info, by default False
        track_data : bool, optional
            whether to generate trade_decision, will be used when making data for multi-level training
            - If `self.track_data` is true, when making data for training, the input `trade_decision` of `execute` will be generated by `collect_data`
            - Else,  `trade_decision` will not be generated
        common_infra : dict, optional:
            common infrastructure for backtesting, may including:
            - trade_account : Account, optional
                trade account for trading
            - trade_exchange : Exchange, optional
                exchange that provides market info

        """
        self.step_bar = step_bar
        self.generate_report = generate_report
        self.verbose = verbose
        self.track_data = track_data
        self.reset(start_time=start_time, end_time=end_time, track_data=track_data, common_infra=common_infra)

    def reset_common_infra(self, common_infra):
        """
        reset infrastructure for trading
            - reset trade_account
        """
        if not hasattr(self, "common_infra"):
            self.common_infra = common_infra
        else:
            self.common_infra.update(common_infra)

        if "trade_account" in common_infra:
            self.trade_account = copy.copy(common_infra.get("trade_account"))
            self.trade_account.reset(freq=self.step_bar, init_report=True)

    def reset(self, track_data: bool = None, common_infra: dict = None, **kwargs):
        """
        - reset `start_time` and `end_time`, used in trade calendar
        - reset `track_data`, used when making data for multi-level training
        - reset `common_infra`, used to reset `trade_account`, `trade_exchange`, .etc
        """

        if track_data is not None:
            self.track_data = track_data

        if common_infra is not None:
            self.reset_common_infra(common_infra)

        if "start_time" in kwargs or "end_time" in kwargs:
            start_time = kwargs.get("start_time")
            end_time = kwargs.get("end_time")
            self.trade_calendar = TradeCalendarManager(step_bar=self.step_bar, start_time=start_time, end_time=end_time)

    def get_level_infra(self):
        return {"trade_calendar": self.trade_calendar}

    def finished(self):
        return self.trade_calendar.finished()

    def execute(self, trade_decision):
        """execute the trade decision and return the executed result

        Parameters
        ----------
        trade_decision : object

        Returns
        ----------
        executed state : List[Tuple[Order, float, float, float]]
            - Each element in the list represents (order, trade value, trade cost, trade price)
        """
        raise NotImplementedError("execute is not implemented!")

    def collect_data(self, trade_decision):
        if self.track_data:
            yield trade_decision
        return self.execute(trade_decision)

    def get_init_state(self):
        raise NotImplementedError("get_init_state in not implemeted!")

    def get_trade_account(self):
        raise NotImplementedError("get_trade_account is not implemented!")

    def get_report(self):
        raise NotImplementedError("get_report is not implemented!")


class SplitExecutor(BaseExecutor):
    from ...strategy.base import BaseStrategy

    def __init__(
        self,
        step_bar: str,
        sub_executor: Union[BaseExecutor, dict],
        sub_strategy: Union[BaseStrategy, dict],
        start_time: Union[str, pd.Timestamp] = None,
        end_time: Union[str, pd.Timestamp] = None,
        trade_exchange: Exchange = None,
        generate_report: bool = False,
        verbose: bool = False,
        track_data: bool = False,
        common_infra: dict = {},
        **kwargs,
    ):
        """
        Parameters
        ----------
        sub_executor : BaseExecutor
            trading env in each trading bar.
        sub_strategy : BaseStrategy
            trading strategy in each trading bar
        trade_exchange : Exchange
            exchange that provides market info, used to generate report
            - If generate_report is None, trade_exchange will be ignored
            - Else If `trade_exchange` is None, self.trade_exchange will be set with common_infra
        """
        self.sub_executor = init_instance_by_config(sub_executor, common_infra=common_infra, accept_types=BaseExecutor)
        self.sub_strategy = init_instance_by_config(
            sub_strategy, common_infra=common_infra, accept_types=self.BaseStrategy
        )

        super(SplitExecutor, self).__init__(
            step_bar=step_bar,
            start_time=start_time,
            end_time=end_time,
            generate_report=generate_report,
            verbose=verbose,
            track_data=track_data,
            common_infra=common_infra,
            **kwargs,
        )

        if generate_report and trade_exchange is not None:
            self.trade_exchange = trade_exchange

    def reset_common_infra(self, common_infra):
        """
        reset infrastructure for trading
            - reset trade_exchange
            - reset substrategy and subexecutor common infra
        """
        super(SplitExecutor, self).reset_common_infra(common_infra)

        if self.generate_report and "trade_exchange" in common_infra:
            self.trade_exchange = common_infra.get("trade_exchange")

        self.sub_executor.reset_common_infra(common_infra)
        self.sub_strategy.reset_common_infra(common_infra)

    def get_init_state(self):
        return []

    def _init_sub_trading(self, trade_decision):
        trade_index = self.trade_calendar.get_trade_index()
        trade_start_time, trade_end_time = self.trade_calendar.get_calendar_time(trade_index)
        self.sub_executor.reset(start_time=trade_start_time, end_time=trade_end_time)
        sub_level_infra = self.sub_executor.get_level_infra()
        self.sub_strategy.reset(level_infra=sub_level_infra, rely_trade_decision=trade_decision)

    def _update_trade_account(self):
        trade_index = self.trade_calendar.get_trade_index()
        trade_start_time, trade_end_time = self.trade_calendar.get_calendar_time(trade_index)
        self.trade_account.update_bar_count()
        if self.generate_report:
            self.trade_account.update_bar_report(
                trade_start_time=trade_start_time,
                trade_end_time=trade_end_time,
                trade_exchange=self.trade_exchange,
            )

    def execute(self, trade_decision):
        self.trade_calendar.step()
        self._init_sub_trading(trade_decision)
        execute_state = []
        sub_execute_state = self.sub_executor.get_init_state()
        while not self.sub_executor.finished():
            sub_trade_decison = self.sub_strategy.generate_trade_decision(sub_execute_state)
            sub_execute_state = self.sub_executor.execute(trade_decision=sub_trade_decison)
            execute_state.extend(sub_execute_state)
        if hasattr(self, "trade_account"):
            self._update_trade_account()

        return execute_state

    def collect_data(self, trade_decision):
        if self.track_data:
            yield trade_decision
        self.trade_calendar.step()
        self._init_sub_trading(trade_decision)
        execute_state = []
        sub_execute_state = self.sub_executor.get_init_state()
        while not self.sub_executor.finished():
            sub_trade_decison = self.sub_strategy.generate_trade_decision(sub_execute_state)
            sub_execute_state = yield from self.sub_executor.collect_data(trade_decision=sub_trade_decison)
            execute_state.extend(sub_execute_state)
        if hasattr(self, "trade_account"):
            self._update_trade_account()

        return execute_state

    def get_report(self):
        sub_env_report_dict = self.sub_executor.get_report()
        if self.generate_report:
            _report = self.trade_account.report.generate_report_dataframe()
            _positions = self.trade_account.get_positions()
            _count, _freq = parse_freq(self.step_bar)
            sub_env_report_dict.update({f"{_count}{_freq}": (_report, _positions)})
        return sub_env_report_dict


class SimulatorExecutor(BaseExecutor):
    def __init__(
        self,
        step_bar: str,
        start_time: Union[str, pd.Timestamp] = None,
        end_time: Union[str, pd.Timestamp] = None,
        trade_exchange: Exchange = None,
        generate_report: bool = False,
        verbose: bool = False,
        track_data: bool = False,
        common_infra: dict = {},
        **kwargs,
    ):
        """
        Parameters
        ----------
        trade_exchange : Exchange
            exchange that provides market info, used to deal order and generate report
            - If `trade_exchange` is None, self.trade_exchange will be set with common_infra
        """
        super(SimulatorExecutor, self).__init__(
            step_bar=step_bar,
            start_time=start_time,
            end_time=end_time,
            generate_report=generate_report,
            verbose=verbose,
            track_data=track_data,
            common_infra=common_infra,
            **kwargs,
        )
        if trade_exchange is not None:
            self.trade_exchange = trade_exchange

    def reset_common_infra(self, common_infra):
        """
        reset infrastructure for trading
            - reset trade_exchange
        """
        super(SimulatorExecutor, self).reset_common_infra(common_infra)
        if "trade_exchange" in common_infra:
            self.trade_exchange = common_infra.get("trade_exchange")

    def get_init_state(self):
        return []

    def execute(self, trade_decision):
        self.trade_calendar.step()
        trade_index = self.trade_calendar.get_trade_index()
        trade_start_time, trade_end_time = self.trade_calendar.get_calendar_time(trade_index)
        execute_state = []
        for order in trade_decision:
            if self.trade_exchange.check_order(order) is True:
                # execute the order
                trade_val, trade_cost, trade_price = self.trade_exchange.deal_order(
                    order, trade_account=self.trade_account
                )
                execute_state.append((order, trade_val, trade_cost, trade_price))
                if self.verbose:
                    if order.direction == Order.SELL:  # sell
                        print(
                            "[I {:%Y-%m-%d}]: sell {}, price {:.2f}, amount {}, deal_amount {}, factor {}, value {:.2f}.".format(
                                trade_start_time,
                                order.stock_id,
                                trade_price,
                                order.amount,
                                order.deal_amount,
                                order.factor,
                                trade_val,
                            )
                        )
                    else:
                        print(
                            "[I {:%Y-%m-%d}]: buy {}, price {:.2f}, amount {}, deal_amount {}, factor {}, value {:.2f}.".format(
                                trade_start_time,
                                order.stock_id,
                                trade_price,
                                order.amount,
                                order.deal_amount,
                                order.factor,
                                trade_val,
                            )
                        )

            else:
                if self.verbose:
                    print("[W {:%Y-%m-%d}]: {} wrong.".format(trade_start_time, order.stock_id))
                # do nothing
                pass

        self.trade_account.update_bar_count()

        if self.generate_report:
            self.trade_account.update_bar_report(
                trade_start_time=trade_start_time,
                trade_end_time=trade_end_time,
                trade_exchange=self.trade_exchange,
            )

        return execute_state

    def get_report(self):
        if self.generate_report:
            _report = self.trade_account.report.generate_report_dataframe()
            _positions = self.trade_account.get_positions()
            _count, _freq = parse_freq(self.step_bar)
            return {f"{_count}{_freq}": (_report, _positions)}
        else:
            return {}
